<?xml version="1.0" encoding="UTF-8"?>
<infozilla-output>
    <Patches amount="2">
        <Patch>
            <index>file_modificato.txt</index>
            <original_file>file_modificato.txt</original_file>
            <modified_file>file_modificato.txt</modified_file>
            <Hunks>
                <hunk>-Riga originale 1
                    -Riga originale 2
                    -Riga originale 3
                    +Riga modificata 1
                    +Riga modificata 2
                    +Riga aggiunta 2.5
                    Riga originale 4
                    -Riga originale 5
                    +Riga modificata 3
                    Riga originale 6</hunk>
                <hunk>-Riga originale 11
                    -Riga originale 12
                    -Riga originale 13
                    +Riga modificata 11
                    +Riga modificata 12
                    +Riga aggiunta 12.5
                    Riga originale 14
                    -Riga originale 15
                    +Riga modificata 13
                    Riga originale 16</hunk>
            </Hunks>
        </Patch>
        <Patch>
            <index>main.java</index>
            <original_file>main.java</original_file>
            <modified_file>main.java</modified_file>
            <Hunks>
                <hunk>public class Main {

                    -    public static void main(String[] args) {
                    +    public static void start(String[] args) {
                    int num1 = 10;
                    int num2 = 20;
                    int sum = num1 + num2;</hunk>
            </Hunks>
        </Patch>
    </Patches>

    <Stacktraces amount="0"/>
    <SourceCodeRegions amount="4">
        <source_code type="functioncall">
            <location start="3438" end="3451" />
            <code>(monitor,1));</code>
        </source_code>
        <source_code type="ifstatement">
            <location start="6038" end="6306" />
            <code>if (isJavaProject) {
                /*IJavaProject jProject = JavaCore.create(project);
                if (jProject.getRawClasspath() != null
                &amp;&amp; jProject.getRawClasspath().length &gt; 0)
                jProject.setRawClasspath(new IClasspathEntry[0], monitor);*/
                modelIds.add(model.getPluginBase().getId());
                }</code>
        </source_code>
        <source_code type="ifstatement">
            <location start="6314" end="6516" />
            <code>if (isJavaProject) {
                IJavaProject jProject = JavaCore.create(project);
                jProject.setRawClasspath(new IClasspathEntry[0], project.getFullPath(),
                monitor);
                modelIds.add(model.getPluginBase().getId());
                }</code>
        </source_code>
        <source_code type="ifstatement">
            <location start="7460" end="7662" />
            <code>if (isJavaProject) {
                IJavaProject jProject = JavaCore.create(project);
                jProject.setRawClasspath(new IClasspathEntry[0], project.getFullPath(),
                monitor);
                modelIds.add(model.getPluginBase().getId());
                }</code>
        </source_code>
    </SourceCodeRegions>
    <Enumerations amount="2">
        <Enumeration lines="23">
            <Lines>
                <Line>1. If autobuilding is on, we turn it off.</Line>
                <Line />
                <Line>2. We import all the plug-ins selected in the import wizard and create a Java</Line>
                <Line>project for each plug-in that contains libraries.  Note that at this step, we</Line>
                <Line>used to clear the classpath of the freshly created Java project because we</Line>
                <Line>will correctly set it at a later step.  However, just before we released 2.1,</Line>
                <Line>Philippe suggested in bug report 34574 that we do not flush the classpath</Line>
                <Line>completely.  So we stopped flushing the classpath at this point, and this</Line>
                <Line>introduced the transient error markers that we now see in the Problems view in</Line>
                <Line>the middle of the operation.  Since these error markers go away later in step</Line>
                <Line>3 when we set the classpath, we regarded them as benign, yet still annoying,</Line>
                <Line>intermediary entities.  This step is done in an IWorkspace.run</Line>
                <Line>(IWorkspaceRunnable, IProgressMonitor) operation.</Line>
                <Line />
                <Line>3. We set the classpath of all the projects that were succesfully imported</Line>
                <Line>into the workspace. This step has to be done in a subsequent IWorkspace.run</Line>
                <Line>(IWorkspaceRunnable, IProgressMonitor) operation for an accurate classpath</Line>
                <Line>computation.  i.e. the Java projects from step 2 have to become part of the</Line>
                <Line>workspace before we set their classpath.</Line>
                <Line />
                <Line>4.  If we had turned autobuilding off in step 1, we turn it back on and invoke</Line>
                <Line>a build via PDEPlugin.getWorkspace().build</Line>
                <Line>(IncrementalProjectBuilder.INCREMENTAL_BUILD,new SubProgressMonitor</Line>
            </Lines>
        </Enumeration>
        <Enumeration lines="6">
            <Lines>
                <Line>- About markers displayed between step 2 and step 3 there's nothing to do on our</Line>
                <Line>side about it.</Line>
                <Line>- At the end of step 2, a PRE_AUTO_BUILD event is sent by the</Line>
                <Line>running operation and processed by our DeltaProcessor which refreshes markers.</Line>
                <Line>- As project were created in step 2 without classpath, then we correctly create a</Line>
                <Line>markers for each concerned project that its .classpath cannot be read.</Line>
            </Lines>
        </Enumeration>
    </Enumerations>
</infozilla-output>

